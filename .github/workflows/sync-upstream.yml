name: "Sync Upstream & Deploy"

permissions:
  contents: write

on:
  # schedule:
  #   # Run daily at 6:00 UTC
  #   - cron: "0 6 * * *"
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if no updates"
        required: false
        default: false
        type: boolean

jobs:
  # ── Stage 1: Merge upstream locally (do NOT push) ──────────────
  merge-staging:
    name: Merge upstream (staging)
    runs-on: ubuntu-latest
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Configure merge drivers
        run: |
          # "accept-upstream" driver: replaces our file with upstream's version
          git config merge.accept-upstream.name "Accept upstream version"
          git config merge.accept-upstream.driver "cp '%B' '%A'"

          # "keep-fork" driver: keeps our fork version unchanged
          git config merge.keep-fork.name "Keep fork version"
          git config merge.keep-fork.driver true

      - name: Add upstream remote and fetch
        run: |
          git remote add upstream https://github.com/TeKrop/overfast-api.git || true
          git fetch upstream

      - name: Check for upstream updates
        id: check
        run: |
          set -euo pipefail
          NEW_COMMITS=$(git log HEAD..upstream/main --oneline)

          if [ -n "$NEW_COMMITS" ]; then
            echo "New upstream commits found:"
            echo "$NEW_COMMITS"
            echo "has_updates=true" >> $GITHUB_OUTPUT
          else
            echo "No new commits from upstream"
            echo "has_updates=false" >> $GITHUB_OUTPUT
          fi

      - name: Merge upstream locally
        if: steps.check.outputs.has_updates == 'true'
        run: |
          git merge upstream/main -m "Merge upstream changes"
          echo "Merge successful — commit not pushed yet"

      - name: Archive merged repository
        if: steps.check.outputs.has_updates == 'true'
        run: tar czf /tmp/merged-repo.tar.gz .

      - name: Upload merged repo artifact
        if: steps.check.outputs.has_updates == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: merged-repo
          path: /tmp/merged-repo.tar.gz
          retention-days: 1

  # ── Stage 2a: Lint & test (parallel with smoke-test) ───────────
  ci-checks:
    name: CI checks (ruff, ty, pytest)
    needs: merge-staging
    if: needs.merge-staging.outputs.has_updates == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Download merged repo
        uses: actions/download-artifact@v4
        with:
          name: merged-repo

      - name: Extract archive
        run: tar xzf merged-repo.tar.gz && rm merged-repo.tar.gz

      - name: Set up uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.9.28"

      - name: Set up Python
        run: uv python install 3.14

      - name: Install the project
        run: uv sync --frozen --no-cache

      - name: Run ruff code analysis
        run: uv run ruff check .

      - name: Run ty code analysis
        run: uv run ty check .

      - name: Run test suite
        run: |
          PYTHONPATH=app/ uv run python -m pytest -v --cov-fail-under=80 --cov-report=term-missing --cov=app/ tests/

  # ── Stage 2b: Docker smoke test (parallel with ci-checks) ─────
  smoke-test:
    name: Smoke test (Docker)
    needs: merge-staging
    if: needs.merge-staging.outputs.has_updates == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Download merged repo
        uses: actions/download-artifact@v4
        with:
          name: merged-repo

      - name: Extract archive
        run: tar xzf merged-repo.tar.gz && rm merged-repo.tar.gz

      - name: Create .env from defaults
        run: |
          cp .env.dist .env
          sed -i 's/^APP_PORT=.*/APP_PORT=8080/' .env

      - name: Build and start services
        run: |
          docker compose build
          docker compose up -d

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for core services (app, nginx, valkey) to become healthy..."
          SERVICES="app nginx valkey"
          TIMEOUT=150
          INTERVAL=5

          for i in $(seq 1 $((TIMEOUT / INTERVAL))); do
            HEALTHY=0
            for SERVICE in $SERVICES; do
              STATUS=$(docker compose ps --format json | jq -rs \
                "[.[] | select(.Service == \"$SERVICE\")] | .[0].Health // \"starting\"")
              if [ "$STATUS" = "healthy" ]; then
                HEALTHY=$((HEALTHY + 1))
              fi
            done

            ELAPSED=$((i * INTERVAL))
            echo "[$ELAPSED/${TIMEOUT}s] $HEALTHY/3 services healthy"

            if [ "$HEALTHY" -eq 3 ]; then
              echo "All core services are healthy!"
              exit 0
            fi

            sleep $INTERVAL
          done

          echo "ERROR: Timed out waiting for services to become healthy"
          docker compose ps
          docker compose logs
          exit 1

      - name: Smoke test endpoints
        run: |
          set -euo pipefail
          BASE_URL="http://localhost:8080"

          check_endpoint() {
            local path="$1"
            local check_body="${2:-false}"

            RESPONSE=$(curl -s -w "\n%{http_code}" "$BASE_URL$path")
            STATUS=$(echo "$RESPONSE" | tail -1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$STATUS" -ne 200 ]; then
              echo "FAIL: GET $path → HTTP $STATUS"
              return 1
            fi

            if [ "$check_body" = "true" ]; then
              if ! echo "$BODY" | jq -e 'length > 0' > /dev/null 2>&1; then
                echo "FAIL: GET $path → 200 but empty response"
                return 1
              fi
              echo "OK: GET $path → 200 (non-empty JSON)"
            else
              echo "OK: GET $path → 200"
            fi
          }

          check_endpoint "/"
          check_endpoint "/openapi.json"
          check_endpoint "/gamemodes" true
          check_endpoint "/maps" true

          echo ""
          echo "All smoke tests passed!"

      - name: Dump logs on failure
        if: failure()
        run: docker compose logs --tail=200

  # ── Stage 3: Push validated merge to main ──────────────────────
  commit-to-main:
    name: Push to main
    needs: [ci-checks, smoke-test]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Configure merge drivers
        run: |
          git config merge.accept-upstream.name "Accept upstream version"
          git config merge.accept-upstream.driver "cp '%B' '%A'"
          git config merge.keep-fork.name "Keep fork version"
          git config merge.keep-fork.driver true

      - name: Merge upstream and push
        run: |
          git remote add upstream https://github.com/TeKrop/overfast-api.git || true
          git fetch upstream
          git fetch origin
          git reset --hard origin/main
          git merge upstream/main -m "Merge upstream changes"
          git push origin main
          echo "Merge commit pushed to main successfully"

  # ──────────────────────────────────────────────────────────────
  # Deploy and notify are disabled until the validation pipeline
  # is proven stable. Re-enable by uncommenting below.
  # ──────────────────────────────────────────────────────────────

  # deploy:
  #   name: Deploy to VPS
  #   needs: commit-to-main
  #   runs-on: ubuntu-latest
  #   if: always() && (needs.commit-to-main.result == 'success' || github.event.inputs.force_deploy == 'true')
  #
  #   steps:
  #     - name: Deploy via SSH
  #       uses: appleboy/ssh-action@v1
  #       with:
  #         host: ${{ secrets.VPS_HOST }}
  #         port: ${{ secrets.VPS_PORT }}
  #         username: ${{ secrets.VPS_USER }}
  #         key: ${{ secrets.VPS_SSH_KEY }}
  #         script: |
  #           /opt/deploy-overfast.sh

  # notify:
  #   name: Send notification
  #   needs: [commit-to-main, deploy]
  #   runs-on: ubuntu-latest
  #   if: always() && needs.commit-to-main.result == 'success'
  #
  #   steps:
  #     - name: Notify app repo of API update
  #       if: needs.deploy.result == 'success'
  #       env:
  #         GH_TOKEN: ${{ secrets.APP_REPO_PAT }}
  #       run: |
  #         gh api \
  #           repos/danielsogl/overwatch_app/dispatches \
  #           -f event_type=api-updated
  #
  #     - name: Notify on failure
  #       if: needs.deploy.result == 'failure'
  #       run: |
  #         echo "Deployment failed!"
