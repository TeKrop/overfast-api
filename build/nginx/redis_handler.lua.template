local zlib = require "zlib"
local redis = require "resty.redis"

local function handle_redis_request()
    -- Initialize Redis client
    local red = redis:new()
    red:set_timeout(1000) -- 1 second timeout

    -- Connect to Redis using hostname and port
    local ok, err = red:connect("${REDIS_HOST}", ${REDIS_PORT})
    if not ok then
        ngx.log(ngx.ERR, "Failed to connect to Redis upstream: ", err)
        return ngx.exit(502)
    end

    -- Create local cleanup method
    local function cleanup()
        local ok_keepalive, kerr = red:set_keepalive(10000, 100)
        if not ok_keepalive then
            ngx.log(ngx.ERR, "Failed to set Redis keepalive: ", kerr)
            red:close()
        end
    end

    -- Redis operations (e.g., GET, TTL)
    local key = "api-cache:" .. ngx.var.request_uri

    -- Use pipeline to reduce round trips
    red:init_pipeline()
    red:get(key)
    red:ttl(key)
    local results, perr = red:commit_pipeline()
    if not results then
        ngx.log(ngx.ERR, "Redis pipeline error: ", perr)
        cleanup()
        return ngx.exit(502)
    end

    local compressed_value = results[1]
    local ttl = results[2]

    -- Cache miss
    if not compressed_value or compressed_value == ngx.null then
        ngx.log(ngx.INFO, "Cache miss for key: ", key)
        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Decompress JSON data
    local status, value = pcall(function()
        return zlib.inflate()(compressed_value)
    end)
    if not value or value == ngx.null then
        ngx.log(ngx.ERR, "Cache error for key: ", key)
        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Send TTL header
    ngx.header["${CACHE_TTL_HEADER}"] = ttl

    -- Output response without adding a newline
    ngx.print(value)

    -- Return connection to Redis pool
    cleanup()
end

return handle_redis_request
