log_by_lua_block {
  if not prometheus then
    return
  end

  -- Normalize endpoint path to avoid high cardinality
  -- IMPORTANT: Keep in sync with Python implementation in app/monitoring/helpers.py
  -- See app/monitoring/README.md for synchronization guidelines
  local function normalize_endpoint(path)
    -- Normalize player paths: /players/<player_id>/... → /players/{player_id}/...
    local normalized = string.gsub(path, "^/players/[^/]+(/.*)", "/players/{player_id}%1")
    if normalized ~= path then
      return normalized
    end

    -- Normalize player path without trailing segments: /players/<player_id> → /players/{player_id}
    normalized = string.gsub(path, "^/players/[^/]+$", "/players/{player_id}")
    if normalized ~= path then
      return normalized
    end

    -- Normalize hero paths: /heroes/<hero_key> → /heroes/{hero_key}
    -- Match single segment after /heroes/ that is NOT "stats"
    if string.match(path, "^/heroes/[^/]+$") and path ~= "/heroes/stats" then
      return "/heroes/{hero_key}"
    end

    return path
  end

  local normalized_endpoint = normalize_endpoint(ngx.var.uri)
  local method = ngx.var.request_method
  local status = ngx.var.status
  local request_time = tonumber(ngx.var.request_time)

  -- Determine cache status from upstream response or cache hit
  local cache_status = "miss"  -- default to miss
  if ngx.var.upstream_addr == nil or ngx.var.upstream_addr == "" then
    -- No upstream = served from cache
    cache_status = "hit"
  end

  -- Record request count with normalized endpoint
  if metric_requests then
    metric_requests:inc(1, {normalized_endpoint, method, status, cache_status})
  end

  -- Record response duration with normalized endpoint
  if metric_latency and request_time then
    metric_latency:observe(request_time, {normalized_endpoint})
  end

  -- Record connection states (updated once per request for current snapshot)
  if metric_connections then
    local connections_active = tonumber(ngx.var.connections_active)
    local connections_reading = tonumber(ngx.var.connections_reading)
    local connections_writing = tonumber(ngx.var.connections_writing)
    local connections_waiting = tonumber(ngx.var.connections_waiting)

    if connections_active then
      metric_connections:set(connections_active, {"active"})
    end
    if connections_reading then
      metric_connections:set(connections_reading, {"reading"})
    end
    if connections_writing then
      metric_connections:set(connections_writing, {"writing"})
    end
    if connections_waiting then
      metric_connections:set(connections_waiting, {"waiting"})
    end
  end
}
