local zlib = require "zlib"
local valkey = require "resty.redis"

local function handle_valkey_request()
    -- Initialize Valkey client
    local valk = valkey:new()
    valk:set_timeout(1000) -- 1 second timeout

    -- Connect to Valkey using hostname and port
    local ok, err = valk:connect("${VALKEY_HOST}", ${VALKEY_PORT})
    if not ok then
        ngx.log(ngx.ERR, "Failed to connect to Valkey upstream: ", err)
        return ngx.exit(502)
    end

    -- Create local cleanup method
    local function cleanup()
        local ok_keepalive, kerr = valk:set_keepalive(10000, 100)
        if not ok_keepalive then
            ngx.log(ngx.ERR, "Failed to set Valkey keepalive: ", kerr)
            valk:close()
        end
    end

    -- Valkey operations (e.g., GET, TTL)
    local key = "api-cache:" .. ngx.var.request_uri

    -- Use pipeline to reduce round trips
    valk:init_pipeline()
    valk:get(key)
    valk:ttl(key)
    local results, perr = valk:commit_pipeline()
    if not results then
        ngx.log(ngx.ERR, "Valkey pipeline error: ", perr)
        cleanup()
        return ngx.exit(502)
    end

    local compressed_value = results[1]
    local ttl = results[2]

    -- Cache miss
    if not compressed_value or compressed_value == ngx.null then
        ngx.log(ngx.INFO, "Cache miss for key: ", key)
        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Decompress JSON data
    local status, value = pcall(function()
        return zlib.inflate()(compressed_value)
    end)
    if not value or value == ngx.null then
        ngx.log(ngx.ERR, "Cache error for key: ", key)
        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Send TTL header
    ngx.header["${CACHE_TTL_HEADER}"] = ttl

    -- Output response without adding a newline
    ngx.print(value)

    -- Return connection to Valkey pool
    cleanup()
end

return handle_valkey_request
