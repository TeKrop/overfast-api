local zstd = require "zstd"
local valkey = require "resty.redis"

local function handle_valkey_request()
    -- These paths never have API cache, always forward to app
    local cache_excluded_paths = { ["/"] = true, ["/docs"] = true, ["/openapi.json"] = true }
    if cache_excluded_paths[ngx.var.uri] then
        ngx.exec("@fallback")
        return
    end

    -- Initialize Valkey client
    local valk = valkey:new()
    valk:set_timeout(1000) -- 1 second timeout

    -- Connect to Valkey using hostname and port
    local ok, err = valk:connect("${VALKEY_HOST}", ${VALKEY_PORT})
    if not ok then
        ngx.log(ngx.ERR, "Failed to connect to Valkey upstream: ", err)
        return ngx.exit(502)
    end

    -- Create local cleanup method
    local function cleanup()
        local ok_keepalive, kerr = valk:set_keepalive(10000, 100)
        if not ok_keepalive then
            ngx.log(ngx.ERR, "Failed to set Valkey keepalive: ", kerr)
            valk:close()
        end
    end

    -- Valkey operations (e.g., GET, TTL)
    local key = "api-cache:" .. ngx.var.request_uri

    -- Use pipeline to reduce round trips
    valk:init_pipeline()
    valk:get(key)
    valk:ttl(key)
    local results, perr = valk:commit_pipeline()
    if not results then
        ngx.log(ngx.ERR, "Valkey pipeline error: ", perr)
        cleanup()
        return ngx.exit(502)
    end

    local compressed_value = results[1]
    local ttl = results[2]

    -- Cache miss - check global rate limit before forwarding to app
    if not compressed_value or compressed_value == ngx.null then
        ngx.log(ngx.INFO, "Cache miss for key: ", key)

        -- Check if Blizzard is currently rate limiting us
        local rate_limit_key = "${BLIZZARD_RATE_LIMIT_KEY}"
        local rate_limit_exists, rl_err = valk:exists(rate_limit_key)
        if rl_err then
            ngx.log(ngx.ERR, "Failed to check rate limit key: ", rl_err)
            cleanup()
            ngx.exec("@fallback")
            return
        end

        -- If rate limited, get TTL and return 429 immediately
        if rate_limit_exists == 1 then
            local rate_limit_ttl, ttl_err = valk:ttl(rate_limit_key)
            if ttl_err or not rate_limit_ttl or rate_limit_ttl < 0 then
                -- If TTL check fails or returns invalid value, use default
                ngx.log(ngx.WARN, "Failed to get rate limit TTL or invalid value: ", tostring(ttl_err or rate_limit_ttl))
                rate_limit_ttl = ${BLIZZARD_RATE_LIMIT_RETRY_AFTER}
            end

            ngx.log(ngx.WARN, "Blizzard rate limit active, returning 429 from nginx")
            ngx.header["${RETRY_AFTER_HEADER}"] = rate_limit_ttl
            ngx.status = ngx.HTTP_TOO_MANY_REQUESTS
            ngx.say('{"error":"API has been rate limited by Blizzard, please wait for ' .. rate_limit_ttl .. ' seconds before retrying"}')
            cleanup()
            return
        end

        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Decompress JSON data (zstd)
    local status, value = pcall(function()
        return zstd.decompress(compressed_value)
    end)
    if not status or not value or value == ngx.null then
        ngx.log(ngx.ERR, "Cache decompression error for key: ", key, " - ", tostring(value))
        cleanup()
        ngx.exec("@fallback")
        return
    end

    -- Send TTL header
    ngx.header["${CACHE_TTL_HEADER}"] = ttl

    -- Output response without adding a newline
    ngx.print(value)

    -- Return connection to Valkey pool
    cleanup()
end

return handle_valkey_request
